/**
 * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
 * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
 * 示例 1:
 * 给定数组 nums = [1,1,2],
 * 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
 * 你不需要考虑数组中超出新长度后面的元素。
 * 示例 2:
 * 给定 nums = [0,0,1,1,1,2,2,3,3,4],
 * 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
 * 你不需要考虑数组中超出新长度后面的元素。
 */

package main

import (
	"testing"
)

func TestRemoveDuplicates(t *testing.T) {
	nums := []int{1, 2, 3, 4, 4}
	//t.Log(RemoveDuplicates1(nums))
	t.Log(RemoveDuplicates2(nums))
	t.Log(nums)
}

/**
* 1 暴力法
* 比较当前元素和前一个元素是否相等，如果相等则后面向前都挪动一个坐标。
*
* 此方法，思路简单，但是编写程序还是不容易的。并且时间复杂度比较高,三层循环 O（n*重复元素个数*(最新数组长度-当前下标))
* 1层循环：得到当前需要比较元素
* 2层循环：在当前下标位置删除元素的个数
* 3层循环：真正移动当前以及后续元素
*
* 需要注意的点：
* 1.应该用当前值和前一个元素进行比较，这样不用考虑数组越界
* 2.第二层循环的终止条件有两个，1）前后元素不相等 2）数组的长度已经减小到了i（第一层循环遍历的位置）
*
 */
func RemoveDuplicates1(nums []int) int {
	l := len(nums)
	for i := 1; i < l; i++ {
		for {
			if nums[i] != nums[i-1] || l <= i {
				break
			}
			for j := i; j < l; j++ {
				nums[j-1] = nums[j]
			}
			l--
		}
	}
	return l
}

/**
 * 解法2 ：双指针法
 * 思路
 * 指针1维护需要比较的元素
 * 指针2维护已经比较的元素
 * 最后返回指针2
 *
 * 分析
 * 思路1的重心是操作未比较的元素
 * 思路2的重心是维护比较的元素
 * 对于此题，显然已经比较后的元素更可控，不需要移动元素，减少复杂度。
 */
func RemoveDuplicates2(nums []int) int {
	p2 := 0
	for p1 := 1; p1 < len(nums); p1++ {
		if nums[p1] != nums[p2] {
			p2++
			nums[p2] = nums[p1]
		}
	}
	return p2 + 1
}
